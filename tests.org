#+name: 16f55b39-9600-434b-b790-18bc644177fc
#+begin_src hy
(import parametrized [parametrized])
(import pytest [mark])
#+end_src

* tests
:PROPERTIES:
:header-args:hy+: :tangle (meq/tangle-path) :prologue (meq/get-block "16f55b39-9600-434b-b790-18bc644177fc")
:header-args:python+: :tangle (meq/tangle-path)
:END:

** conftest.py

Adapted from [[https://stackoverflow.com/users/347181/draganhr][draganHR's]] answer [[https://stackoverflow.com/a/35394239/10827766][here]]:

#+begin_src python
import pytest

@pytest.fixture()
def cookies(request):
    from pathlib import Path
    return Path(request.config.rootdir).resolve(strict = True) / "cookies"

@pytest.fixture()
def cookies_ls(cookies):
    from subprocess import check_output
    return sorted(filter(None, check_output(["ls", cookies]).decode("utf-8").split("\n")))

@pytest.fixture()
def cookies_generator(cookies):
    from oreo import is_visible
    from os import listdir
    return (item for item in listdir(cookies) if is_visible(item))

@pytest.fixture()
def cookies_listdir(cookies_generator):
    return sorted(cookies_generator)
#+end_src

** test-eclair.hy

#+begin_src hy
(import oreo [eclair])
(defn [mark.eclair] test-eclair [] (for [i (eclair (range 100) "69611341-cf92-48bb-8cda-79c7fe28d9f2" "red")]))
#+end_src

** test-gensing.hy

#+begin_src hy
(import oreo [tea])
(defn [mark.gensing] test-gensing []
      (setv test (tea :a "b" :c "d"))
      (.append test "f")
      (.extend test "h" "j" "l")
      (.glue test "mnop")
      (.glue test (tea :q "r" :s "t"))
      (.glue test ["v" "x"])
      (assert (= (test) "b d f h j lmnopr tv x")))
(defn [mark.gensing (.parametrize mark "b" [
      { :a "b" :c "d" }
      { "a" "b" "c" "d" }
      ["b" "d"]
      "b d"
      (tea :a "b" :c "d")
      (tea "b" "d")
])] test-gensing-equality [b]
      (setv a (tea :a "b" :c "d"))
      (assert (= a b)))
#+end_src

** test-either?.hy

#+begin_src hy
(import addict [Dict])
(import collections [OrderedDict])
(import oreo [either?])
(defn [mark.either (.parametrize mark "types" [
      #(OrderedDict dict)
      #(OrderedDict Dict)
      #(Dict dict)
      #("Dict" str)
      #("OrderedDict" "Dict" list)
      #("OrderedDict" "Dict")
])] test-either [types] (assert (either? #* types)))
(defn [mark.either (.parametrize mark "types" [
      #("Dict" Dict)
      #("Dict" Dict list)
])] test-either-false [types] (assert (= (either? #* types) False)))
#+end_src

** test-first-last-n.hy

#+begin_src hy
(import oreo [first-last-n])
(setv ten (range 10))
(defn [mark.first-last-n] test-first-5 [] (assert (= (list (range 5)) (first-last-n :iterable ten :number 5 :type- list))))
(defn [mark.first-last-n] test-last-5 [] (assert (= (list (range 5 10)) (first-last-n :iterable ten :number 5 :last True :type- list))))
#+end_src

** test-remove-prefix-suffix-n.hy

#+begin_src hy
(import oreo [remove-prefix-n remove-suffix-n])
(setv fives (range 5))
(defn [mark.remove-prefix-n parametrized.zip] test-remove-prefix-n [[n fives] [output #("yourboat" "rowrowyourboat" "rowyourboat" "yourboat" "yourboat")]]
      (assert (= (remove-prefix-n :string "rowrowrowyourboat" :prefix "row" :n n))))
(defn [mark.remove-suffix-n parametrized.zip] test-remove-suffix-n [[n fives] [output #("lets" "letsgogo" "letsgo" "lets" "lets")]]
      (assert (= (remove-prefix-n :string "letsgogogo" :prefix "go" :n n))))
(defn [mark.remove-prefix-n parametrized.zip] test-remove-single-character-prefix-n [[n fives] [output #("yb" "rryb" "ryb" "yb" "yb")]]
      (assert (= (remove-prefix-n :string "rrryb" :prefix "r" :n n))))
(defn [mark.remove-suffix-n parametrized.zip] test-remove-single-character-suffix-n [[n fives] [output #("l" "lgg" "lg" "l" "l")]]
      (assert (= (remove-prefix-n :string "lggg" :prefix "g" :n n))))
#+end_src

** test-flatten.hy

#+begin_src hy
(import oreo [flatten])
(setv nested #(1 #(2 #(3 #(4))))
      flattened [1 2 3 4]
      outputs #(nested [1 2 #(3 #(4))] [1 2 3 #(4)] flattened)
      fives (range 5))
(defn [mark.flatten] test-flatten-one-item [] (assert (= (flatten 1) [1])))
(defn [mark.flatten] test-flatten-all [] (assert (= (flatten nested) flattened)))
(defn [mark.flatten parametrized.zip] test-flatten [[times fives] [output outputs]] (assert (= (flatten nested :times times) output)))
(defn [mark.flatten] test-flatten-all-unpacked [] (assert (= (flatten #* nested) flattened)))
(defn [mark.flatten parametrized.zip] test-flatten-unpacked [[times fives] [output outputs]] (assert (= (flatten #* nested :times times) output)))
#+end_src

** test-with-cwd.hy

#+begin_src hy
(import pathlib [Path])
(require oreo [with-cwd])
(defn [mark.with-cwd] test-with-cwd [cookies]
      (let [ cwd (.cwd Path) ]
           (with-cwd cookies (assert (= (.cwd Path) cookies)))
           (assert (= (.cwd Path) cwd))))
#+end_src

** test-let-cwd.hy

#+begin_src hy
(import pathlib [Path] hy)
(require oreo [let-cwd])
(defn [mark.let-cwd] test-let-cwd [cookies]
      (setv cwd (.cwd Path))
      (let-cwd cookies [ cwd cwd ] (assert (= (.cwd Path) cookies)))
      (assert (= (.cwd Path) cwd)))
#+end_src

** test-ls.hy

#+begin_src hy
(import oreo [ls])
(require oreo [with-cwd])
(import pathlib [Path])
(try (import cytoolz [first])
     (except [ImportError]
             (import toolz [first])))
(setv funcs #(
      (fn [cookies] (ls cookies :sort True))
      (fn [cookies] (ls (str cookies) :sort True))
      (fn [cookies] (ls cookies :key True))
))
(defn [mark.ls parametrized.zip] test-ls-ls [cookies cookies-ls [func funcs]] (assert (= ((first func) cookies) cookies-ls)))
(defn [mark.ls parametrized.zip] test-ls-listdir [cookies cookies-listdir [func funcs]] (assert (= ((first func) cookies) cookies-listdir)))
(defn [mark.ls] test-ls-sort-reverse [cookies cookies-listdir] (assert (= (cut cookies-listdir None None -1) (ls cookies :reverse True))))
(defn [mark.ls] test-ls-cwd [cookies] (with-cwd cookies (assert (= (ls :sort True) (ls cookies :sort True)))))
(defn [mark.ls] test-ls-sort-key-function [cookies cookies-generator]
      (let [ func (fn [item] (if (.isnumeric item) (int item) -1)) ]
           (assert (= (sorted cookies-generator :key func)
                      (ls cookies :key func)))))
(defn [mark.ls] test-ls-with-ls-listdir [cookies] (assert (= (ls cookies :sort True) (ls (str cookies) :sort True))))
#+end_src
